{"meta":{"title":"Happy Coding L","subtitle":"","description":"","author":"Li Shangli","url":"http://lishangli.github.io","root":"/"},"pages":[],"posts":[{"title":"原函数存在定理","slug":"原函数存在定理","date":"2021-07-22T12:33:52.000Z","updated":"2021-07-22T12:42:45.303Z","comments":true,"path":"2021/07/22/原函数存在定理/","link":"","permalink":"http://lishangli.github.io/2021/07/22/%E5%8E%9F%E5%87%BD%E6%95%B0%E5%AD%98%E5%9C%A8%E5%AE%9A%E7%90%86/","excerpt":"","text":"设F’（x）=f(x)，f（x）在x=x0处不连续，则x0必为第二类间断点（对于考研数学，只能是第二类振荡间断点），而非第一类间断点或第二类无穷间断点。 当f(x)存在第二类振荡间断点时，不能确定是否存在原函数，这种情况下结论与f(x)的表达式有关。 原函数存在的三个结论： 如果f(x)连续，则一定存在原函数； 如果f(x)不连续，有第一类可去、跳跃间断点或第二类无穷间断点，那么包含此间断点的区间内，一定不存在原函数； 如果f(x)不连续，有第二类振荡间断点，那么包含此间断点的区间内，原函数可能存在，也可能不存在","categories":[],"tags":[{"name":"math","slug":"math","permalink":"http://lishangli.github.io/tags/math/"}]},{"title":"my-first-blog","slug":"my-first-blog","date":"2021-06-15T12:46:03.000Z","updated":"2021-06-16T07:54:37.376Z","comments":true,"path":"2021/06/15/my-first-blog/","link":"","permalink":"http://lishangli.github.io/2021/06/15/my-first-blog/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Test","slug":"Python学习笔记","date":"2021-06-15T12:46:03.000Z","updated":"2021-06-16T07:08:00.213Z","comments":true,"path":"2021/06/15/Python学习笔记/","link":"","permalink":"http://lishangli.github.io/2021/06/15/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Python学习笔记实例112345678print(&#x27;----------i love python ---------&#x27;)temp=input(&quot;guess the number:&quot;);guess=int(temp)if guess == 8: print(&quot;true\\n&quot;)else: print(&quot;false\\n&quot;)print(&quot;end&quot;)","categories":[],"tags":[{"name":"Languages","slug":"Languages","permalink":"http://lishangli.github.io/tags/Languages/"}]},{"title":"my-first-blog","slug":"石子游戏","date":"2021-06-15T12:46:03.000Z","updated":"2021-06-16T07:05:56.549Z","comments":true,"path":"2021/06/15/石子游戏/","link":"","permalink":"http://lishangli.github.io/2021/06/15/%7F%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/","excerpt":"","text":"亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 示例： 输入：[5,3,4,5]输出：true解释：亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。假设他取了前 5 颗，这一行就变成了 [3,4,5] 。如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 提示： 2 &lt;= piles.length &lt;= 500piles.length 是偶数。1 &lt;= piles[i] &lt;= 500sum(piles) 是奇数。 动态规划+前缀和解法 1234567891011121314151617181920212223242526class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int a[505][505]; int sums[505]; int len =piles.size(); sums[0]=piles[0]; for(int i=1;i&lt;len;++i) &#123; sums[i]=sums[i-1]+piles[i]; a[i][i]=piles[i]; &#125; int suml; for(int i=2;i&lt;=len;++i) &#123; for(int j=0;j+i-1&lt;len;++j) &#123; suml = sums[j+i-1]-(j==0?0:sums[j-1]); //else suml = sums[j+i-1]; a[j][j+i-1]=max(suml-a[j][j+i-2],suml-a[j+1][j+i-1]); &#125; &#125; return 2*a[0][len-1]&gt;(sums[len-1]); &#125;&#125;; 数学 可以推出先手必胜 123456class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; return 1; &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://lishangli.github.io/tags/Algorithm/"}]},{"title":"编译原理","slug":"语义分析","date":"2021-06-15T12:46:03.000Z","updated":"2021-06-16T10:59:39.611Z","comments":true,"path":"2021/06/15/语义分析/","link":"","permalink":"http://lishangli.github.io/2021/06/15/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/","excerpt":"sssssss","text":"sssssss 语义分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581/*一个简单的翻译模式P→ DS.D→B; DD→εB→int L | real LL→id | L，idS→ V := E HH→；S | εE→E+T | TT→( E )T→idV→idstart-&gt; DS.D-&gt;B; DD-&gt;εB-&gt;int L &#123; L.type := int &#125;|real L &#123; L.type := real &#125;L-&gt;id &#123; A.Type := L.type enter(v.entry,L.type)&#125; AA-&gt; ，idA &#123; A1.Type := A.type enter(v.entry,A.type)&#125;A-&gt;εS→ V := E &#123; gen( &quot;:=&quot;, E.place,0,V.place) &#125; HH→；S | εE-&gt;T &#123; R.i:=T.place&#125; R &#123;E.place:=R.s&#125;R-&gt;+T &#123; R1.i:= newtemp; gen( &quot;*&quot;, R.i, T.place , R1.i) &#125; R &#123;R.s:= R1.s; &#125;R-&gt; ε &#123;Rs=R.i&#125;T-&gt;( E ) &#123; T.place := E.place&#125;T-&gt;id &#123;T.place:=found (id)&#125;V-&gt;id &#123;V.place:=found(id)&#125;*/#include &quot;语义分析.h&quot;int main()&#123; char filename[20]; printf(&quot;请输入分析的文件名:&quot;); gets(filename); if((fin=fopen(filename,&quot;r&quot;))==NULL) &#123; printf(&quot;不能打开文件.\\n&quot;); exit(0); &#125; init(); //初始化 getsym(); //读第一个单词，将单词类别放入sym中，单字词值放入id中 start(); //开始按start-&gt;DS. 分析 if (sym==eeof) &#123; printf(&quot;语法正确\\n\\n将中间代码保存到文件请输入文件名，否则回车&quot;); gets(filename); if(strlen(filename)&lt;=0) return 0; if((fout=fopen(filename,&quot;w&quot;))==NULL) &#123; printf(&quot;不能打开文件.\\n&quot;); exit(0); &#125; for (int cx1=0;cx1&lt;cx;cx1++) fprintf(fout,&quot;(%s,%s,%s,%s)\\n&quot;,code[cx1].f,code[cx1].l,code[cx1].r,code[cx1].t); return 0; &#125; else &#123;printf(&quot;语法错1: . 后不能再有句子&quot;); exit(0);&#125; fclose(fin); fclose(fout); return 0;&#125;//初始化函数void init()&#123; int i; /* 设置单字符符号 */ for (i=0; i&lt;=255; i++) &#123; ssym[i] = nul; //不正确的单字符符号为nul，先预置初值nul &#125; ssym[&#x27;+&#x27;] = plus; ssym[&#x27;-&#x27;] = minus; ssym[&#x27;*&#x27;] = times; ssym[&#x27;/&#x27;] = divide; ssym[&#x27;(&#x27;] = lparen; ssym[&#x27;)&#x27;] = rparen; ssym[&#x27;.&#x27;] = period; ssym[&#x27;,&#x27;] = comma; ssym[&#x27;;&#x27;] = semicolon; /* 设置保留字名字 */ strcpy(&amp;(word[0][0]), &quot;real&quot;); strcpy(&amp;(word[1][0]), &quot;int&quot;); /* 设置保留字符号 */ wsym[0] = realsym; wsym[1] = intsym; tv=100; //临时变量指针初值，让Tx和tv的取值没有交集，区别到底是临时变变量和声明的变量 tx=0; //表指针初值 cx=0; //指令计数器&#125;bool reals=false,ints=false;/** 词法分析，获取一个符号*/int getsym()&#123; int i,k; ch=fgetc(fin); if (ch==EOF) &#123;sym=eeof; return 0;&#125; //文件结束 while (ch==&#x27; &#x27; || ch==10 || ch==13 || ch==9) /* 忽略空格、换行、回车和TAB */ ch=fgetc(fin); if (ch&gt;=&#x27;a&#x27; &amp;&amp; ch&lt;=&#x27;z&#x27;) &#123; /* 名字或保留字以a..z开头 ，*/ k = 0; do &#123; if(k&lt;al) /* 符号的最大长度为al ，超长就截尾处理*/ &#123; a[k] = ch; k++; &#125; ch=fgetc(fin); &#125; while (ch&gt;=&#x27;a&#x27; &amp;&amp; ch&lt;=&#x27;z&#x27; || ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;); a[k] = 0; strcpy(id, a); fseek(fin,-1,1); for (i=0;i&lt;norw;i++) /* 搜索当前符号是否为保留字 */ if (strcmp(id,word[i]) == 0) break; if (i &lt;norw) &#123; sym = wsym[i]; &#125; else &#123; sym = ident; /* 搜索失败则，类型是标识符 */ &#125; &#125; else if(ch == &#x27;:&#x27;) /* 检测赋值符号 */ &#123; ch=fgetc(fin); if (ch == &#x27;=&#x27;) &#123; sym = becomes; &#125; else &#123; sym = nul; /* 不能识别的符号 */ &#125; &#125; else sym = ssym[ch]; /* 当符号不满足上述条件时，全部按照单字符符号处理 */ return 0;&#125;/** 在符号表中加入一项*/void enter(enum symbol type)&#123; tx=tx+1; if (tx &gt; txmax) &#123; printf(&quot; 符号表越界 &quot;); /* 符号表越界 */ return; &#125; for(int i=0;i&lt;tx;++i)&#123; if(strcmp(table[i].name, id)==0&amp;&amp;table[i].type==type)&#123;printf(&quot;禁止重复同名标识符\\n&quot;);exit(0);&#125;&#125; strcpy(table[tx].name, id); /* 全局变量id中已存有当前名字的名字,Tx为插入当前符号之前表尾指针 */ table[tx].type = type; //for(int i=0;i&lt;10;++i) printf(&quot;%c&quot;,id[i]); //printf(&quot;\\n%d\\n&quot;,sym);&#125;/** 查找名字的位置.* 找到则返回在名字表中的位置,否则返回0.** idt: 要查找的名字* tx: 当前名字表尾指针，全局变量*/int found(char* idt)&#123; int i; strcpy(table[0].name, idt); i = tx; while (strcmp(table[i].name, idt) != 0) &#123; i--; &#125; return i;&#125;/* 中间代码*/int gen(enum symbol op, int arg1, int arg2,int result )&#123; char temp1[al+1],temp2[al+1],temp3[al+1]; if(arg1&gt;=100) //模拟申请临时变量 &#123; wsprintf(temp1,&quot;T%d&quot;,arg1); &#125; else &#123; strcpy(temp1, table[arg1].name); &#125; if(arg2&gt;=100) &#123; wsprintf(temp2,&quot;T%d&quot;,arg2); &#125; else &#123; strcpy(temp2, table[arg2].name); &#125; if(result&gt;=100) &#123; wsprintf(temp3,&quot;T%d&quot;,result); &#125; else &#123; strcpy(temp3,table[result].name); &#125; if (op==becomes) &#123; printf(&quot;(:=,%s,%s,%s)\\n&quot;,temp1,temp2,temp3); writecode(&quot;:=&quot;,temp1,temp2,temp3); &#125; else if (op==plus) //+运算 &#123; writecode(&quot;+&quot;,temp1,temp2,temp3); printf(&quot;(+,%s,%s,%s)\\n&quot;,temp1,temp2,temp3); &#125; else if (op==minus) //+运算 &#123; writecode(&quot;-&quot;,temp1,temp2,temp3); printf(&quot;(-,%s,%s,%s)\\n&quot;,temp1,temp2,temp3); &#125; else if (op==times) //+运算 &#123; writecode(&quot;*&quot;,temp1,temp2,temp3); printf(&quot;(*,%s,%s,%s)\\n&quot;,temp1,temp2,temp3); &#125; else if (op==divide) //+运算 &#123; writecode(&quot;/&quot;,temp1,temp2,temp3); printf(&quot;(/,%s,%s,%s)\\n&quot;,temp1,temp2,temp3); &#125; return 0;&#125;//处理代码段void writecode(char op[al+1], char arg1[al+1], char arg2[al+1],char result[al+1] )&#123; if (cx &gt;= cxmax) &#123; printf(&quot;Program too long&quot;); /* 程序过长 */ return ; &#125; strcpy(code[cx].f, op); strcpy(code[cx].l,arg1); strcpy(code[cx].r,arg2); strcpy(code[cx].t,result); cx++; return ;&#125;/*分析产生式 P-&gt;DS. */void start()&#123; if (sym==intsym ||sym==realsym) &#123; D(); S(); if (sym==period) &#123; getsym(); return; &#125; else &#123;printf(&quot;语法错2： 缺少程序结束.&quot;); exit(0);&#125; &#125; else &#123;printf(&quot;语法错3: 程序只能用int,和real开始，而且区分大小写&quot;); exit(0);&#125;&#125;/*递归下降分析D-&gt; B; DD-&gt;ε*/void D()&#123; if (sym==intsym ||sym==realsym) &#123; B(); if (ch=&#x27;;&#x27;) &#123; getsym(); D(); &#125; else &#123;printf(&quot;语法错i&quot;); exit(0);&#125; &#125; else if(sym==ident || sym==period) return; else &#123;printf(&quot;语法错ii&quot;); exit(0);&#125;&#125;/*B-&gt; int L &#123; L.type := int &#125;|real L &#123; L.type := real &#125;*/void B()&#123; if (sym==intsym ) &#123; getsym(); L(intsym); &#125; else if (sym==realsym) &#123; getsym(); L(realsym); &#125;else &#123;printf(&quot;语法错iii&quot;); exit(0);&#125;&#125;/*L-&gt; id &#123; A.Type := L.type enter(v.entry,L.type)&#125; A V.entry通过全局变量tx隐性传递*/void L(enum symbol type)&#123; if (sym==ident) &#123; enter(type); getsym(); A(type); &#125; else &#123;printf(&quot;语法错iv&quot;); exit(0);&#125;&#125;/*A-&gt; ，id A &#123; A1.Type := A.type enter(v.entry,A.type)&#125;A-&gt;ε*/void A(enum symbol type)&#123; if (sym==comma) //当前单词为， &#123; getsym(); if (sym==ident) &#123; enter(type); getsym(); A(type); &#125; else &#123;printf(&quot;语法错v&quot;); exit(0);&#125; &#125; else if (sym== semicolon) return ;//当前单词为；即A的follow集元素，相当于进行A-&gt;ε else &#123;printf(&quot;语法错vi&quot;); exit(0);&#125;&#125;/*S→ V := E &#123; gen( &quot;:=&quot;, E.place,0,V.place) &#125; H*/void S()&#123; int vplace,Eplace; if (sym==ident) &#123; vplace=V(); //getsym(); if (sym==becomes) //当前单词为:= &#123; getsym(); Eplace=E(); if(reals&amp;&amp;ints) &#123;printf(&quot;语法错vvi&quot;); exit(0);&#125; gen(becomes,Eplace,-1,vplace); H(); &#125; else &#123;printf(&quot;语法错vii&quot;); exit(0);&#125; &#125; else &#123;printf(&quot;语法错viii&quot;); exit(0);&#125;&#125;/*H→；S | ε*/void H()&#123; if (sym==semicolon) //当前单词为indent类型 &#123; reals=false,ints=false; getsym(); S(); &#125; else if (sym==period) return ; else &#123;printf(&quot;语法错ivv&quot;); exit(0);&#125;&#125;/*E-&gt;T &#123; R.i:=T.place&#125; R &#123;E.place:=R.s&#125;*/int E()&#123; int ri,tplace,Rs; if (sym==ident || sym== lparen) &#123; tplace=T(); ri=tplace; Rs=R(ri); &#125; else &#123;printf(&quot;语法错vv&quot;); exit(0);&#125; return Rs;&#125;/*R-&gt;+T &#123; R1.i:= newtemp; gen( &quot;*&quot;, R.i, T.place , R1.i) &#125; R &#123;R.s:= R1.s; &#125;R-&gt; ε &#123;R.s=R.i&#125;*/int R(int Ri)&#123; int Rs,tplace; if (sym==plus) &#123; getsym(); tplace=T(); if(reals&amp;&amp;ints) &#123;printf(&quot;运算变量类型不一致&quot;); exit(0);&#125; tv=tv+1; //生成临时变量 gen(plus,Ri,tplace,tv); Rs=R(tv); &#125; else if(sym==minus) &#123; getsym(); tplace=T(); if(reals&amp;&amp;ints) &#123;printf(&quot;运算变量类型不一致&quot;); exit(0);&#125; tv=tv+1; //生成临时变量 gen(minus,Ri,tplace,tv); Rs=R(tv); &#125; else if (sym== semicolon || sym==rparen|| sym==period) &#123; Rs=Ri; &#125; else &#123;printf(&quot;语法错vvi&quot;); exit(0);&#125; return Rs;&#125;/*T-&gt;( E ) &#123; T.place := E.place&#125;T-&gt;id &#123;F.place:=found (id)&#125;*/int T()&#123; int ri,tplace,Rs; if (sym==ident || sym== lparen) &#123; tplace=F(); ri=tplace; Rs=P(ri); &#125; else &#123;printf(&quot;语法错vvii&quot;); exit(0);&#125; return Rs;&#125;int F()&#123; int Fplace; if (sym== lparen) &#123; getsym(); Fplace=E(); if (sym== rparen) getsym(); else &#123; printf(&quot;语法错，缺)&quot;); exit(0); &#125; &#125; else if (sym==ident) &#123; Fplace=found (id); if (Fplace==0) &#123;printf(&quot;变量没有声明&quot;); exit(0);&#125; if(table[Fplace].type==realsym) reals=true; else ints=true; getsym(); &#125; else&#123;printf(&quot;语法错,缺(&quot;); exit(0);&#125; return Fplace;&#125;int P(int Ri)&#123; int Rs,tplace; if (sym==times) &#123; getsym(); tplace=F(); if(reals&amp;&amp;ints) &#123;printf(&quot;运算变量类型不一致&quot;); exit(0);&#125; tv=tv+1; //生成临时变量 gen(times,Ri,tplace,tv); Rs=P(tv); &#125; else if(sym==divide) &#123; getsym(); tplace=F(); if(reals&amp;&amp;ints) &#123;printf(&quot;运算变量类型不一致&quot;); exit(0);&#125; tv=tv+1; //生成临时变量 gen(divide,Ri,tplace,tv); Rs=P(tv); &#125; else if (sym== semicolon || sym==rparen|| sym==period||sym==plus||sym==minus) &#123; Rs=Ri; &#125; else &#123;printf(&quot;%d语法错vviii&quot;,sym); exit(0);&#125; return Rs;&#125;/*V-&gt;id &#123;V.place:=found(id)&#125;*/int V()&#123; int Vplace; if (sym==ident) &#123; Vplace=found (id); if (Vplace==0) &#123;printf(&quot;变量没有声明&quot;); exit(0);&#125; if(table[Vplace].type==realsym) reals=true; else ints=true; getsym(); &#125; else&#123;printf(&quot;语法错ivvv&quot;); exit(0);&#125; return Vplace;&#125; 语义分析.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include&lt;dos.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;//#include &lt;iostream.h&gt;#include&lt;ctype.h&gt;#include &lt;windows.h&gt;#define txmax 100 /* 锟斤拷锟脚憋拷锟斤拷锟斤拷锟斤拷锟� */#define al 10 /* 锟斤拷锟脚碉拷锟斤拷蟪ざ锟� */#define tvmax 500 /* 锟斤拷锟斤拷芄锟斤拷锟斤拷锟斤拷锟斤拷时锟斤拷锟斤拷取值锟斤拷围[100, tvmax] */#define norw 2 /* 锟截硷拷锟街革拷锟斤拷 */#define cxmax 500 /* 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟� */int tx; //锟斤拷锟街憋拷指锟斤拷, 取值锟斤拷围[0, txmax-1]int tv ; //锟斤拷时锟斤拷锟斤拷锟斤拷锟斤拷/* 锟斤拷锟斤拷 */enum symbol &#123; nul, eeof, ident, plus, minus , times, lparen,divide, rparen, comma, semicolon, becomes, period, realsym, intsym,&#125;;enum symbol sym; /* 锟斤拷前锟侥凤拷锟斤拷 */char ch; /* 锟斤拷取锟街凤拷锟侥伙拷锟斤拷锟斤拷锟斤拷getch 使锟斤拷 */char id[al+1]; /* 锟斤拷前ident, 锟斤拷锟斤拷锟揭伙拷锟斤拷纸锟斤拷锟斤拷诖锟斤拷0 */char a[al+1]; /* 锟斤拷时锟斤拷锟斤拷, 锟斤拷锟斤拷锟揭伙拷锟斤拷纸锟斤拷锟斤拷诖锟斤拷0 *//* 锟斤拷锟脚憋拷锟结构 */struct tablestruct&#123; char name[al]; /* 锟斤拷锟斤拷 */ enum symbol type; // 锟斤拷锟斤拷&#125;;struct tablestruct table[txmax]; /* 锟斤拷锟脚憋拷 */char word[norw][al]; /* 锟斤拷锟斤拷锟斤拷 */enum symbol wsym[norw]; /* 锟斤拷锟斤拷锟街讹拷应锟侥凤拷锟斤拷值 */enum symbol ssym[256]; /* 锟斤拷锟街凤拷锟侥凤拷锟斤拷值锟斤拷散锟叫憋拷 */int cx; /* 锟斤拷元式锟斤拷锟斤拷指锟斤拷, 取值锟斤拷围[0, cxmax-1]*/struct instruction&#123; char f[al+1]; /* 锟斤拷锟斤拷锟斤拷 */ char l[al+1]; /* 锟斤拷锟斤拷锟斤拷锟� */ char r[al+1]; /* 锟揭诧拷锟斤拷锟斤拷*/ char t[al+1]; /* 锟斤拷锟� */&#125;;struct instruction code[cxmax]; /* 锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟� */FILE* fin;FILE* fout;int getsym();void enter(enum symbol type);void init();int found(char* idt);int gen(enum symbol op, int arg1, int arg2,int result ); //锟叫硷拷锟斤拷锟斤拷锟斤拷void writecode(char *op, char *arg1, char *arg2,char *result ); //写锟斤拷锟斤拷void start();void D();void B();void L(enum symbol type);void A(enum symbol type);void S();void H();int E();int R(int Ri);int T();int V();int F();int P(int Ri);","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://lishangli.github.io/tags/Algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-06-15T11:51:34.816Z","updated":"2021-06-15T11:51:34.816Z","comments":true,"path":"2021/06/15/hello-world/","link":"","permalink":"http://lishangli.github.io/2021/06/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"math","slug":"math","permalink":"http://lishangli.github.io/tags/math/"},{"name":"Languages","slug":"Languages","permalink":"http://lishangli.github.io/tags/Languages/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://lishangli.github.io/tags/Algorithm/"}]}